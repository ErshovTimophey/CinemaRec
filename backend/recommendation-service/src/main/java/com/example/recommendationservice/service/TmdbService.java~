package com.example.recommendationservice.service;

import com.example.recommendationservice.dto.TmdbMovie;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class TmdbService {

    @Value("${tmdb.api.base-url}")
    private String tmdbBaseUrl;

    @Value("${tmdb.api.image-base-url}")
    private String imageBaseUrl;

    @Value("${tmdb.api.key}")
    private String tmdbApiKey;

    private final RestTemplate restTemplate;
    private final HttpHeaders headers;

    @Getter
    private final Map<Integer, String> genreMap = new HashMap<>();

    // Минимальные пороги для фильтрации
    private static final int MIN_VOTE_COUNT = 100; // Минимум 100 голосов
    private static final double MIN_POPULARITY = 10.0; // Минимум 10.0 популярности

    public TmdbService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
        headers = new HttpHeaders();
        headers.set("accept", "application/json");
        headers.set("Authorization", "Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZDQ2MmI5MTYxZGM3NDIwMzI0NWVjMDcyOWRmZjM4NyIsIm5iZiI6MTc0NzA2MzAxOC41MzUsInN1YiI6IjY4MjIxMGVhMzJmNzNlMTJlNDczOTNjNyIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.Xx1dOcNyzFsIMIB3h3hD006NVEoZMFXsF6d7GVlUsTA");
    }

    public RecommendationsByCategory getRecommendations(List<String> favoriteGenres,
                                                        List<String> favoriteActors,
                                                        List<String> favoriteMovies,
                                                        List<String> favoriteDirectors,
                                                        Double minRating) {
        try {
            Random random = new Random();
            RecommendationsByCategory result = new RecommendationsByCategory();

            // Рекомендации по похожим фильмам
            List<TmdbMovie> movieRecommendations = new ArrayList<>();
            for (String movieId : favoriteMovies) {
                movieRecommendations.addAll(getSimilarMovies(movieId, 2));
            }
            result.setMovieRecommendations(filterAndLimit(movieRecommendations, minRating, random, 5));

            // Рекомендации по актерам
            List<TmdbMovie> actorRecommendations = new ArrayList<>();
            for (String actorId : favoriteActors) {
                actorRecommendations.addAll(getMoviesByPerson(actorId, "cast"));
            }
            result.setActorRecommendations(filterAndLimit(actorRecommendations, minRating, random, 5));

            // Рекомендации по режиссерам
            List<TmdbMovie> directorRecommendations = new ArrayList<>();
            for (String directorId : favoriteDirectors) {
                directorRecommendations.addAll(getMoviesByPerson(directorId, "crew"));
            }
            result.setDirectorRecommendations(filterAndLimit(directorRecommendations, minRating, random, 5));

            // Рекомендации по жанрам с случайной сортировкой
            String[] sortOptions = {"popularity.desc", "vote_average.desc", "release_date.desc"};
            String sortBy = sortOptions[random.nextInt(sortOptions.length)];
            List<TmdbMovie> genreRecommendations = discoverMovies(favoriteGenres, minRating, sortBy, 2);
            result.setGenreRecommendations(filterAndLimit(genreRecommendations, minRating, random, 5));

            return result;

        } catch (Exception e) {
            log.error("Error getting recommendations from TMDB", e);
            return new RecommendationsByCategory();
        }
    }

    private List<TmdbMovie> filterAndLimit(List<TmdbMovie> movies, Double minRating, Random random, int limit) {
        List<TmdbMovie> filteredMovies = new ArrayList<>(
                movies.stream()
                        .filter(movie -> movie.getVoteAverage() >= minRating)
                        .filter(movie -> movie.getVoteCount() != null && movie.getVoteCount() >= MIN_VOTE_COUNT)
                        .filter(movie -> movie.getPopularity() != null && movie.getPopularity() >= MIN_POPULARITY)
                        .sorted(Comparator.comparing(TmdbMovie::getVoteAverage).reversed())
                        .toList()
        );

        if (filteredMovies.isEmpty()) {
            log.warn("No movies found after filtering with minRating={}, minVoteCount={}, minPopularity={}",
                    minRating, MIN_VOTE_COUNT, MIN_POPULARITY);
            return Collections.emptyList();
        }

        Collections.shuffle(filteredMovies, random);
        return filteredMovies.stream()
                .limit(limit)
                .toList();
    }

    private List<TmdbMovie> getSimilarMovies(String movieId, int pages) {
        List<TmdbMovie> movies = new ArrayList<>();
        for (int page = 1; page <= pages; page++) {
            String url = UriComponentsBuilder.fromHttpUrl(tmdbBaseUrl)
                    .path("/movie/{movieId}/similar")
                    .queryParam("page", page)
                    .queryParam("vote_count.gte", MIN_VOTE_COUNT)
                    .buildAndExpand(movieId)
                    .toUriString();
            movies.addAll(fetchMovies(url));
        }
        return movies;
    }

    private List<TmdbMovie> getMoviesByPerson(String personId, String creditType) {
        String url = UriComponentsBuilder.fromHttpUrl(tmdbBaseUrl)
                .path("/person/{personId}/movie_credits")
                .queryParam("vote_count.gte", MIN_VOTE_COUNT)
                .buildAndExpand(personId)
                .toUriString();

        ResponseEntity<Map> response = restTemplate.exchange(
                url, HttpMethod.GET, new HttpEntity<>(headers), Map.class);

        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            List<Map<String, Object>> credits = (List<Map<String, Object>>) response.getBody().get(creditType);
            return credits.stream()
                    .map(this::mapToTmdbMovie)
                    .toList();
        }
        return Collections.emptyList();
    }

    private List<TmdbMovie> discoverMovies(List<String> genres, Double minRating, String sortBy, int pages) {
        List<TmdbMovie> movies = new ArrayList<>();
        String genreQuery = String.join(",", genres.stream().map(String::valueOf).toList());

        for (int page = 1; page <= pages; page++) {
            String url = UriComponentsBuilder.fromHttpUrl(tmdbBaseUrl)
                    .path("/discover/movie")
                    .queryParam("with_genres", genreQuery)
                    .queryParam("vote_average.gte", minRating)
                    .queryParam("vote_count.gte", MIN_VOTE_COUNT)
                    .queryParam("popularity.gte", MIN_POPULARITY)
                    .queryParam("sort_by", sortBy)
                    .queryParam("page", page)
                    .build()
                    .toUriString();
            movies.addAll(fetchMovies(url));
        }
        return movies;
    }

    private List<TmdbMovie> fetchMovies(String url) {
        ResponseEntity<Map> response = restTemplate.exchange(
                url, HttpMethod.GET, new HttpEntity<>(headers), Map.class);

        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            List<Map<String, Object>> results = (List<Map<String, Object>>) response.getBody().get("results");
            return results.stream()
                    .map(this::mapToTmdbMovie)
                    .toList();
        }
        return Collections.emptyList();
    }

    private TmdbMovie mapToTmdbMovie(Map<String, Object> movieMap) {
        loadGenresIfNeeded();
        TmdbMovie movie = new TmdbMovie();
        movie.setId((Integer) movieMap.get("id"));
        movie.setTitle((String) movieMap.get("title"));
        movie.setOverview((String) movieMap.get("overview"));
        movie.setPosterPath((String) movieMap.get("poster_path"));
        movie.setVoteAverage(
                movieMap.get("vote_average") instanceof Number ?
                        ((Number) movieMap.get("vote_average")).doubleValue() : 0.0);
        movie.setVoteCount(
                movieMap.get("vote_count") instanceof Number ?
                        ((Number) movieMap.get("vote_count")).intValue() : 0);
        movie.setPopularity(
                movieMap.get("popularity") instanceof Number ?
                        ((Number) movieMap.get("popularity")).doubleValue() : 0.0);
        if (movieMap.get("genre_ids") instanceof List<?>) {
            List<Integer> ids = (List<Integer>) movieMap.get("genre_ids");
            movie.setGenreIds(ids);
            List<String> names = ids.stream()
                    .map(genreMap::get)
                    .filter(Objects::nonNull)
                    .toList();
            movie.setGenreNames(names);
        }
        return movie;
    }

    void loadGenresIfNeeded() {
        if (!genreMap.isEmpty()) return;
        String url = UriComponentsBuilder.fromHttpUrl(tmdbBaseUrl)
                .path("/genre/movie/list")
                .toUriString();
        ResponseEntity<Map> response = restTemplate.exchange(
                url, HttpMethod.GET, new HttpEntity<>(headers), Map.class);
        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            List<Map<String, Object>> genres = (List<Map<String, Object>>) response.getBody().get("genres");
            for (Map<String, Object> genre : genres) {
                genreMap.put((Integer) genre.get("id"), (String) genre.get("name"));
            }
        }
    }

    public String getFullPosterUrl(String posterPath) {
        return posterPath != null ? imageBaseUrl + posterPath : null;
    }

    // Внутренний класс для структурированных рекомендаций
    public static class RecommendationsByCategory {
        private List<TmdbMovie> actorRecommendations = new ArrayList<>();
        private List<TmdbMovie> genreRecommendations = new ArrayList<>();
        private List<TmdbMovie> directorRecommendations = new ArrayList<>();
        private List<TmdbMovie> movieRecommendations = new ArrayList<>();

        public List<TmdbMovie> getActorRecommendations() {
            return actorRecommendations;
        }

        public void setActorRecommendations(List<TmdbMovie> actorRecommendations) {
            this.actorRecommendations = actorRecommendations;
        }

        public List<TmdbMovie> getGenreRecommendations() {
            return genreRecommendations;
        }

        public void setGenreRecommendations(List<TmdbMovie> genreRecommendations) {
            this.genreRecommendations = genreRecommendations;
        }

        public List<TmdbMovie> getDirectorRecommendations() {
            return directorRecommendations;
        }

        public void setDirectorRecommendations(List<TmdbMovie> directorRecommendations) {
            this.directorRecommendations = directorRecommendations;
        }

        public List<TmdbMovie> getMovieRecommendations() {
            return movieRecommendations;
        }

        public void setMovieRecommendations(List<TmdbMovie> movieRecommendations) {
            this.movieRecommendations = movieRecommendations;
        }
    }
}
